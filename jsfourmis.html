<html>
 <head>
  <script type="application/x-javascript">
	var JSFOURMIS = {};	// Création du namespace
	(function(){ 		// Portée locale
	/* test */
		/** --------------------------------------------------- *
		 * @class Matrix 
		 * Classe statique "boite à outil" pour manipuler les
		 * formes, etc..
		 * ---------------------------------------------------- */
		JSFOURMIS.Matrix = {
			aggrandir: function(matrix) {
			}
		};
		
		/** --------------------------------------------------- *
		 * @class Fourmi 
		 * Fait tout ce que fait une fourmi :)
		 * ---------------------------------------------------- */
		 
		/**
		 * Constructeur 
		 * @param kanvasObj: instance de JSFOURMIS.Kanvas appellante (son "this" quoi)
		 * @param parentObj: instance de l'objet dans lequel se trouve la nourriture.
		 */
		JSFOURMIS.Nourriture = function(kanvasObj, parentObj) {
			parentObj = parentObj || kanvasObj;
			this.kanvasObj = kanvasObj;
			this.parentObj = parentObj;
		};
		
		/** 
		 * Méthodes publiques
		 */
		JSFOURMIS.Nourriture.prototype = {
			kanvasObj: {},
			parentObj: {},
			couleur: function() {/* @TODO: dépend de la quantité */},
			x: 0,
			y: 0,
			quantitee: 0,
			estDessinable: function(){return true; /* @TODO: sauf si transporté par une fourmis, etc.. */},
			dessine: function(){/* @TODO */}
		};
		
		/** --------------------------------------------------- *
		 * @class Fourmi 
		 * Fait tout ce que fait une fourmi :)
		 * ---------------------------------------------------- */
		 
		/**
		 * Constructeur
		 * On la place dans la fourmilière, sans direction précise.
		 * @param kanvasObj: instance de JSFOURMIS.Kanvas appellante (son "this" quoi)
		 */
		JSFOURMIS.Fourmi = function(kanvasObj) {
			this.kanvasObj = kanvasObj;
			this.direction = JSFOURMIS.Directions.AUCUNE;
			this.x = this.kanvasObj.foyer.x;
			this.y = this.kanvasObj.foyer.y;
		};
		/** 
		 * Méthodes publiques
		 */
		JSFOURMIS.Fourmi.prototype = {
			kanvasObj: {},		// cf. Constructeur
			x: 0, 				// Position x de la fourmi
			y: 0, 				// Position y de la fourmi
			aller: true,		// Indique si la fourmi cherche..
			retour: false,		// ..ou si elle revient à la fourmilière (consciament s'entend)
			direction: null,	// Direction de la fourmi. cf. l'Enum "JSFOURMIS.Direction"
			nourritures: [],	// instances des "Nourriture" transportées
			age: 0,				// Age de la fourmi (en Cycles)
			couleur: {r:0, g:0, b:0, a:0xff},	// Couleur de la fourmis

			/**
			 * Indique si la fourmi doit mourrir
			 * (parcequ'elle est trop vielle par exemple)
			 * @return: booléan
			 */
			doitMourrir: function() {		
				//...if(this.age)...
				return false;
			},

			/**
			 * Fait mourrir la fourmi. 
			 * @TODO
			 */
			meur: function() {
			},
			
			/** 
			 * La fourmi est-elle déssinable ?
			 * Exemple: on peu vouloir une fourmi "fantome", 
			 * ou encore une fourmie "pré-paramêtrée" pour plus tard, ou 
			 * filtrer l'affichage par type de fourmis, ou que sais-je encore..
			 * Par défaut, une fourmis est déssinable.
			 * @return booléen
			 */
			estDessinable: function(){return true;},
			
			/**
			 * Déssine la fourmi.
			 * Définie la forme de la fourmie, et apelle la méthode
			 * de JSFOURMIS.Kanvas de déssin de forme (dessineForme()) avec
			 * la bonne position, forme, et couleur.
			 * @param x 
			 * @param y
			 */
			dessine: function () {
				var forme = {
						h: 5,
						w: 3,
						data:	[1,1,1,
								 0,1,0,
								 1,1,1,
								 0,1,0,
								 1,1,1]
						};
				this.kanvasObj.dessineForme(forme, this.x, this.y, this.couleur);
			},
		};		
	
		/** --------------------------------------------------- *
		 * @class Kanvas 
		 * Classe principale du bouzin, fait un peu tout.
		 * ---------------------------------------------------- */
		 
		 /**
		  * Constructeur
		  */
		JSFOURMIS.Kanvas = function () {
			this.entitees.fourmis = this.fourmis;
		};	
		/** 
		 * Méthodes publiques
		 */
		JSFOURMIS.Kanvas.prototype = {
			canvas: null, 	//<@ Canvas
			ctx: null,		//<@ Contexte du canvas
		
			/** 
			 * Zone de déssin par pixel du canvas. 
			 * On ne travaille que la dessus normalement.
			 */
			imageData: {},
			
			/** 
			 * Déssine un pixel sur la zone de déssin.
			 * @param x
			 * @param y
			 * @param couleur: objet {} ayant 4 propriétés r,g,b et a (transparance)
			 */
			setPixel: function(x,y, couleur) {
				var index = (x + y * this.imageData.width) * 4;
				this.imageData.data[index+0] = couleur.r;
				this.imageData.data[index+1] = couleur.g;
				this.imageData.data[index+2] = couleur.b;
				this.imageData.data[index+3] = couleur.a;
			},
			
			/**
			 * Vérifie si la forme est valide pour une entitée
			 * Une forme valide doit avoir une largeur et une 
			 * hauteur impair, comme ça, on peu la centrer sur 
			 * la position donnée.
			 * @TODO vérifier la concordance h*w = taille du tableau
			 */
			estUneFormeValide: function (forme) {
				var reste_h = forme.data.h % 2;
				var reste_w = forme.data.w % 2;
				return !(reste_w + reste_h == 0);
			},
			
			/**
			 * Déssine une forme. Typiquement la forme d'une entitée.
			 * Une forme est un objet {} doté de 3 propriétés:
			 * w: la largeur de la forme
			 * h: la hauteur de la forme
			 * data: un tableau *à une dimension* représentant la forme.
			 * data doit contenir soit 1: plein, soit 0: vide.
			 * Exemple d'une forme de croix:
			 * <code>
			 * var croix = { 
			 *		h: 3, w: 3,
			 *		data: [	0,1,0,
			 *				1,1,1,
			 *				0,1,1 ] };
			 * </code>
			 */
			dessineForme: function (forme, x, y, couleur){
				if(!this.estUneFormeValide(forme)) {
					throw "La forme fournie n'est pas une forme valide.";
				}
				var centre_h_forme = forme.h % 2;
				var centre_w_forme = forme.w % 2;
				var pix_x = 0;
				var pix_y = 0;
				for(var fy=0; fy<forme.h; fy++) {
					for(var fx=0; fx<forme.w; fx++) {
						var index = fy*forme.w + fx;
						if(forme.data[index] == 1) {
							//x
							if(x < centre_w_forme) {
								pix_x = x - fx;
							} else if(x > centre_h_forme) {
								pix_x = x + fx;
							} else {
								pix_x = x;
							}
							//y
							if(y < centre_h_forme) {
								pix_y = y - fy;
							} else if(y > centre_h_forme) {
								pix_y = y + fy;
							} else {
								pix_y = y;
							}
							this.setPixel(pix_x, pix_y, couleur);
						}
					}
				}
			},
			
			effaceNouriture: function(x,  y) {
			},
			
			/**
			 * Hauteur du canvas
			 * DOIT être Impair (c'est mieux, on à un centre)
			 * Renseigné en principe dans le constructeur ou le start()
			 */
			height: 0,
			/** 
			 * Largeur du canvas
			 * DOIT être Impair (c'est mieux, on à un centre)
			 * Renseigné en principe dans le constructeur ou le start()
			 */
			width: 0,
			
			disperseDeLaNourriture: function() {
				var maxTantatives = 100;
				for(var i=0; i<this.nbInitialDePointDeNourriture; i++) {
					var tantatives = 0;
					while( tantatives < maxTantatives ) {
						var x = this.random(1, this.width);
						var y = this.random(1, this.height);
						if(this.laPlaceEstElleLibre(x, y)) {
							this.creerUnPointDeNourriture(x, y);
							break;
						} else tantatives++;
					}
				}
			},
			
			creerUnPointDeNourriture: function(x, y) {
				// nbMinNourritureParPointDeNourriture: 1,
				// nbMaxNourritureParPointDeNourriture: 10,
				// quantiteeMinParNourriture: 1,
				// quantiteeMaxParNourriture: 10,
				//new JSFOURMIS.Nourriture(this, 
				//KNOO:J'en suis la
			},
			
			/**
			 * Indique la présence ou non d'une entitée à la position donnée
			 * @param x
			 * @param y
			 * @return bool: vrai s'il n'y à rien, faux sinon.
			 */
			laPlaceEstElleLibre: function( x, y ) {
				//FIXME: Problème ! 
				// Comment savoir si la place est libre
				// sans avoir à itérer toutes les entitées
				// déssinables..
				// faudrait garder dans un tableau de la taille de l'image
				// un genre de référence des objets à cette position
				// un truc comme ça.. sinon, ca peut être relou pour rien
				// je pense. Nope ?
				//
				// En attendant..
				for(var uneEntitee in this.entitees) {
					for(var i=0; i<this.entitees[uneEntitee].length; i++){
						if(this.entitees[uneEntitee][i].x == x 
						&& this.entitees[uneEntitee][i].y == y) {
							return false;
						}
					}
				}
				return true;
			},
			
			/** 
			 * Random borné (têtu celui-là..)
			 */
			random: function(lower, higher) {
				return Math.floor((Math.random() * (higher-lower)) + lower);
			},
			
			/**
			 * Fait avancer une fourmi (pour un cycle).
			 */
			avance: function(fourmi) {
				//TODO: faire la *vrai* fonction.. 
				// la c'est une direction aléatoire..
				var distanceAParcourrir = 1;
				var xOuY = this.random(1,100);
				var moinsOuPlus = this.random(1,100);
				if(xOuY<=50) {
					if(moinsOuPlus <=50) {
						fourmi.x += distanceAParcourrir;
					} else {
						fourmi.x -= distanceAParcourrir;
					}
				} else {
					if(moinsOuPlus <=50) {
						fourmi.y += distanceAParcourrir;
					} else {
						fourmi.y -= distanceAParcourrir;
					}
				}
			},
			
			/**
			 * Emplacement de la fourmilière
			 * En principe choisi dans le constructeur ou le start()
			 */
			foyer: {
				x: 0,
				y: 0
			},
			
			/**
			 * Indique si la position donnée
			 * est inclue dans la zone de déssin ou dépasse
			 */
			estDansLaZone: function (x, y) {
				var yEst = true;
				if(x<0 || x>=this.width) yEst = false;
				if(y<0 || y>=this.height) yEst = false;
				return yEst;
			},
		
			ilYADeLaNourriture: function( x, y ) {
			},
		
			/** 
			 * Efface tout le contenu du canvas
			 */
			effaceTout: function() {
				this.imageData = this.ctx.createImageData(this.width, this.height); 
			},
			
			/** 
			 * Déssine chaque entitée déssinable
			 * Cette méthode est donc appellé logiquement
			 * quand leurs positions sont déjà mises à jour
			 */
			dessineTout: function (){
				for(var uneEntitee in this.entitees) {
					for(var i=0; i<this.entitees[uneEntitee].length; i++){
						if(this.entitees[uneEntitee][i].estDessinable()) {
							this.entitees[uneEntitee][i].dessine();
						}
					}
				}
				this.ctx.putImageData(this.imageData, 0, 0); // at coords 0,0
			},
			
			/**
			 * Liste les différentes entitées 
			 * et le tableau les stockant pour
			 * chaqune d'entre elles
			 */
			entitees: {
				fourmis: this.fourmis
				//nourritures: this.nourritures,
				//pheromones: this.pheromones
			},
			
			/** 
			 * Boucle principale
			 */
			main: function() {
				if(this.nbCycles != -1) {
					JSFOURMIS.Kanvas.compteurCycles++;
				}
				this.effaceTout();
				
				for(var i=0; i<this.fourmis.length; i++) {
					var nouvellePos = this.avance(this.fourmis[i]);
				}
	
				for(var i=0; i<this.fourmis.length; i++) {
					this.fourmis[i].age++;
					if(this.fourmis[i].doitMourrir())
						this.fourmis[i].meur();
				}
				this.dessineTout();
				if(this.running) {
					if(JSFOURMIS.Kanvas.compteurCycles <= this.nbCycles || this.nbCycles == -1)
						window.setTimeout(function(thisObj){thisObj.main();}, this.delaiCycle, this );
				}
			},
			
			/**
			 * Délai entre 2 cycles, en ms
			 */
			delaiCycle: 20,
			
			/**
			 * Nombre de cycles à éxecuter
			 */
			nbCycles: 0,
			
			//nourriture stuff
			nbInitialDePointDeNourriture: 50,
			nbMinNourritureParPointDeNourriture: 1,
			nbMaxNourritureParPointDeNourriture: 10,
			quantiteeMinParNourriture: 1,
			quantiteeMaxParNourriture: 10,
			
			/**
			 * Drapeau indiquant l'état actuel de la boucle principale
			 */
			running: false,
			
			/**
			 * Initialisation
			 * Déclenché au clic du bouton start
			 */
			start: function() {
				// Récup du canvas et de sa taille
				this.canvas = document.getElementById("canvas");
				this.ctx = this.canvas.getContext("2d");
				this.height = parseInt(this.canvas.getAttribute('height'));
				this.width = parseInt(this.canvas.getAttribute('width'));
				
				// on place la fourmilière au centre
				this.foyer.y = this.height/2;
				this.foyer.x = this.width/2;
				
				// créé une "imageData", zone de travail par pixel
				this.imageData = this.ctx.createImageData(this.width, this.height); //  /!\
				
				var nbfourmis = parseInt($('nbFourmis').value);
				this.nbCycles = parseInt($('nbCycles').value);
				
				// A chaque nouveau départ, on ré-init le compteur
				JSFOURMIS.Kanvas.compteurCycles = 0;
				
				//dispersion du mangé
				this.disperseDeLaNourriture();
				
				//création des fourmis
				for(var i=0; i<nbfourmis; i++){	
					this.fourmis.push(new JSFOURMIS.Fourmi(this));
				}
				this.running = true;
				this.main();
			},
			
			/** 
			 * Tableau des JSFOURMIS.Fourmi (des fourmis quoi)
			 */
			fourmis: [],
			
			/**
			 * Stop l'écoulement des cycles
			 */
			stop: function() {
				JSFOURMIS.Kanvas.compteurCycles = this.nbCycles + 1;
				this.running = false;
			}
		};
		
		JSFOURMIS.Directions = {
				NORD: 1,
				SUD: 2,
				EST: 3,
				OUEST: 4,
				AUCUNE: 5
		};
		var self = JSFOURMIS.Kanvas;
	})(); // Fin du scope locale
	var $ = function(e){ return document.getElementById(e); }
	var k = new JSFOURMIS.Kanvas();
  </script>
  <style type="text/css">
	td.orientation { text-align: center;}
  </style>
 </head>
 <body>
	<center>
		<table>
			<tr>
				<td></td>
				<td id='nord' class="orientation">Nord</td>
				<td></td>
			</tr>
			<tr>
				<td id='est' class="orientation">Est</td>
				<td>
					<!-- ICI le CANVAS, ICI -->
					<canvas style="border: 1px solid gray;" id="canvas" width="300" height="300"></canvas>
				</td>
				<td id='ouest' class="orientation">Ouest</td>
			</tr>
			<tr>
				<td></td>
				<td id='sud' class="orientation">Sud</td>
				<td></td>
			</tr>
		</table>
		
		<!-- Nombre de cycles à executer -->
		Cycles: <input type="text" id="nbCycles" value="5"/><br/>
		
		<!-- Nombre de fourmis en jeux -->
		Fourmis: <input type="text" id="nbFourmis" value="20"/><br/>
		
		<button onclick="k.start();">START</button>
		<button onclick="k.stop();">STOP</button>
	</center>
 </body>
</html>